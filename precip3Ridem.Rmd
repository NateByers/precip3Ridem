---
title: "R Tutorial: Precipitation Graphs, Pt 3"
author: "Nathan Byers"
date: "Tuesday, July 24, 2014"
output: 
  html_document:
    fig_height: 6
    fig_width: 9
    theme: readable
---

In <a href="http://rpubs.com/NateByers/precipRidem" target="_blank">part 1</a>
of this tutorial we tidied up some data from the `IDEMdata` package, and in
<a href="http://rpubs.com/NateByers/precip2Ridem" target="_blank">part 2</a> we 
used that data to create precipitation graphs. In this part we will use functions
and loops to automate the creation of these graphs. 

## Functions

Functions in R are created using the following general format:

```{r, eval=FALSE}
myFunction <- function(){
  
}
```

So functions are created just like other variables in R, with the assignment
operator `<-`. Arguments for the function are placed inside the brackets `()` 
and the statements for the function are placed inside the braces `{}`. The last line
of the statements will be returned when the function is used. For example, here 
is a function that calculates the mean of a vector.

```{r}
myMean <- function(vector){
  sum.of.vector <- sum(vector)
  number.of.values <- length(vector)
  average <- sum.of.vector/number.of.values
  average
}
```

Now we can use this like any other function in R.

```{r}
myMean(vector = rnorm(10))
```

## Plot function

We're going to write our own function that will take watershed data and create
a precipitation graph. We'll call our function `precipPlot()` and it'll have
the following general outline:

```{r, eval=FALSE}
precipPlot <- function(date, precip, sample, trellis = FALSE, ...){
  
  if(trellis == FALSE){
    
    # lattice plot statements
    
  } else if(trellis == TRUE){
    
    # lattice plot statements with conditional
    
  } 
  
  # double y scale plot statements
  
}
  
```

The three arguments we have so far are the minimum arguments we need to create
a graph. We'll add more as we go along. Right now the requirements for these
arguments are that `date` has the `"Date"` class and that `precip` and `sample` have
the `"numeric"` class; that the three vectors are of the same length (and are
ordered appropriately); and that `trellis` is either `TRUE` or `FALSE`.

Now we'll simply add code for the plot into braces. 

```{r}
precipPlot <- function(date, precip, sample, trellis, sample.label, ...){
  
  if(trellis == FALSE){
    
    rain <- xyplot(precip ~ date, type = "h", ylab = "Precipitation (in)",
                   xlab = "Date")

    sample <- xyplot(sample  ~ date, type = "p", ylab = sample.label, 
                     ylim = c(0, 2*max(sample, na.rm = TRUE)))
    
  } else if(trellis == TRUE){
    
    time <- as.POSIXlt(date)
    
    month.year <- format(time, "%b, %Y")
    
    month.year <- factor(month.year, levels = unique(month.year))
    
    rows <- length(levels(month.year))/3
    
    mday <- time$mday
    
    rain <- xyplot(precip ~ mday | month.year, type = "h",
                   ylab = "Precipitation (in)", layout = c(3, rows), as.table = TRUE, 
                   xlab = "")
    
    sample <- xyplot(sample  ~ mday | month.year, type = "p", ylab = sample.label,
                  ylim = c(0, 2*max(sample, na.rm = TRUE)))
    
  } 
  
  doubley <- doubleYScale(rain, sample, add.ylab2 = TRUE, under = TRUE, 
                          text = c( "Precipitation (in)", sample.label),
                          column = 2, type = c("l", "p"))
  
  update(doubley,
         par.settings = simpleTheme(col = c("black", "red"), pch = c(NA, 16)))
  
}
  
```

Before we can use this function, we need data in the proper format. So we'll write
a function that subsets the `wide.precip.df` data frame, properly formats the 
data, and calls the `precipPlot` function.

```{r}
precipSubsetPlot <- function(data, site, site.col, date.col, precip.col, 
                             sample.col, sample.name, conditioned, save = TRUE,
                             file.extension = "png", ...){
  
  site.df <- data[data[, site.col] == site, c(date.col, sample.col)]
  
  precip.df <- unique(data[, c(date.col, precip.col)])
  
  site.df <- merge(precip.df, site.df, all = TRUE)
  
  remove(data, precip.df)
  
  plot <- precipPlot(date = site.df[, date.col], precip = site.df[, precip.col],
                     sample = site.df[, sample.col], trellis = conditioned,
                     sample.label = sample.name)
  
  if(save){
    
    file.name <- paste(site, sample.col, "precip_graph", sep = "_")
    
    
    file.name <- paste(file.name, file.extension, sep = ".")
    
    trellis.device(device = file.extension, filename = file.name)
    
    print(plot)
    
    dev.off()
    
  } else {
    
    plot
    
    }
  
}

```

This function takes a data frame (the argument `data`) that is in the wide format,
subsets it down to a particular sampling site, creates a precipitation graph
of the specified sampled data, and saves it. Let's see if it works. The following
code should save a `.png` file in your working directory.

```{r, eval=FALSE}
library(lattice)
library(latticeExtra)
library(IDEMdata)

data(wide_precip)

precipSubsetPlot(data = wide.precip.df, site = "LMG-05-0009", site.col = "station", 
                 date.col = "date", precip.col = "precipitation",  sample.col = "sat", 
                 sample.name = "% Saturation", conditioned = "TRUE", save = TRUE, 
                 file.extension = "png")

```








